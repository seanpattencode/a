Generated: 2025-10-02 01:08:33

aios_start.py:
#!/usr/bin/env python3
import subprocess, sys
sys.path.append('/home/seanpatten/projects/AIOS')
command = (sys.argv + ["start"])[1]
subprocess.run(["python3", f"/home/seanpatten/projects/AIOS/core/aios_{command}.py"] + sys.argv[2:])


core/aios_runner.py:
#!/usr/bin/env python3
import subprocess, sys, signal, os
cmd_str = ' '.join(sys.argv[1:]).lower()
timeout = float(os.getenv('AIOS_TIMEOUT', max([max([999999 * min(1, cmd_str.find(p) + 1) for p in ['web.py', 'aios_api.py', 'scheduler.py', 'poll', 'watch', 'serve', 'autollm', 'claude', 'codex']]), max([5.0 * min(1, cmd_str.find(p) + 1) for p in ['wiki_fetcher', 'scraper', 'gdrive', 'curl', 'wget', 'git', 'npm', 'pip']]), 0.1])))
signal.signal(signal.SIGALRM, sys.exit)
signal.setitimer(signal.ITIMER_REAL, timeout)
result = subprocess.run(sys.argv[1:], capture_output=True, text=True)
signal.alarm(0)
print(result.stdout, end='')
sys.stderr.write(str(result.stderr))
sys.exit(result.returncode)


core/aios_status.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS')
from core import aios_db
print(f"PIDs: {aios_db.read('aios_pids')}")


core/aios_stop.py:
#!/usr/bin/env python3
import subprocess, sys
sys.path.append('/home/seanpatten/projects/AIOS')
from core import aios_db
subprocess.run(["pkill", "-9", "-f", "core/aios_api.py"], stderr=subprocess.DEVNULL)
subprocess.run(["pkill", "-9", "-f", "services/web/web.py"], stderr=subprocess.DEVNULL)
aios_db.write("aios_pids", {})
print("AIOS stopped")


core/aios_db.py:
import json, sqlite3, pathlib
d = sqlite3.connect(str(pathlib.Path(__file__).parent.parent / "data/aios.db"), isolation_level=None, check_same_thread=False)
d.execute("PRAGMA synchronous=0")
d.execute("PRAGMA journal_mode=MEMORY")
d.executescript("CREATE TABLE IF NOT EXISTS kv(k TEXT PRIMARY KEY,v TEXT);CREATE TABLE IF NOT EXISTS jobs(id INTEGER PRIMARY KEY,name TEXT,status TEXT,output TEXT,created TIMESTAMP DEFAULT CURRENT_TIMESTAMP);CREATE TABLE IF NOT EXISTS messages(id INTEGER PRIMARY KEY,content TEXT,timestamp TEXT,source TEXT,priority INTEGER DEFAULT 0);CREATE TABLE IF NOT EXISTS worktrees(id INTEGER PRIMARY KEY,repo TEXT,branch TEXT,path TEXT,job_id INTEGER,model TEXT,task TEXT,status TEXT,output TEXT,created TIMESTAMP DEFAULT CURRENT_TIMESTAMP);CREATE TABLE IF NOT EXISTS events(id INTEGER PRIMARY KEY,target TEXT,data TEXT,created TIMESTAMP DEFAULT CURRENT_TIMESTAMP)")
def read(n):
    return json.loads(d.execute("SELECT v FROM kv WHERE k=?", (n,)).fetchone()[0])
def write(n, x):
    d.execute("INSERT OR REPLACE INTO kv VALUES(?,?)", (n, json.dumps(x, indent=2)))
    return x
def query(_, s, p=()):
    return d.execute(s, p).fetchall()
def execute(_, s, p=()):
    d.execute(s, p)


core/aios_start.py:
#!/usr/bin/env python3
import subprocess, time, sys, socket, webbrowser
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS')
from core import aios_db

def find_free_port(start_port=8080, max_attempts=10):
    """Find a free port starting from start_port"""
    for port in range(start_port, start_port + max_attempts):
        try:
            test_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            test_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            test_sock.bind(('', port))
            test_sock.close()
            return port
        except OSError:
            continue
    raise RuntimeError(f"No free ports found between {start_port} and {start_port + max_attempts}")

def find_free_api_port(start_port=8000, max_attempts=10):
    """Find a free port for API starting from start_port"""
    for port in range(start_port, start_port + max_attempts):
        try:
            test_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            test_sock.bind(('', port))
            test_sock.close()
            return port
        except OSError:
            continue
    raise RuntimeError(f"No free API ports found between {start_port} and {start_port + max_attempts}")

aios_path = Path.home() / ".aios"
start_time = time.time()

# Don't kill existing instances - allow multiple sessions
# subprocess.run(["pkill", "-9", "-f", "core/aios_api.py"], stderr=subprocess.DEVNULL)
# subprocess.run(["pkill", "-9", "-f", "services/web/web.py"], stderr=subprocess.DEVNULL)

aios_path.mkdir(exist_ok=True)

# Find available ports
web_port = find_free_port(8080)
api_port = find_free_api_port(8000)

# Save port info
aios_db.write("ports", {"web": web_port, "api": api_port})
aios_db.write("aios_pids", {})

# Create web socket
web_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
web_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
web_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)
web_sock.bind(('', web_port))
web_sock.listen(5)

# Start API with dynamic port
api_proc = subprocess.Popen(["python3", "core/aios_api.py", str(api_port)], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

# Start web server with socket and port info
web_proc = subprocess.Popen(["python3", "services/web/web.py", str(web_sock.fileno()), str(web_port), str(api_port)], pass_fds=[web_sock.fileno()])
web_sock.close()

aios_db.write("aios_pids", {"api": api_proc.pid, "web": web_proc.pid})
elapsed = time.time() - start_time
print(f"AIOS started in {elapsed:.3f}s: http://localhost:{web_port}")
webbrowser.open(f"http://localhost:{web_port}")
subprocess.Popen(["python3", "-c", "from services import context_generator; context_generator.generate()"], cwd="/home/seanpatten/projects/AIOS")

core/aios_api.py:
#!/usr/bin/env python3
from fastapi import FastAPI, Request
import sys
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db, uvicorn
app = FastAPI()
@app.get("/data/{name}")
async def get_data(name: str):
    return aios_db.read(name)
@app.post("/data/{name}")
async def post_data(name: str, request: Request):
    return aios_db.write(name, await request.json())
@app.post("/event/{target}")
async def emit_event(target: str, request: Request):
    aios_db.execute("events", "INSERT INTO events(target, data) VALUES (?, ?)", (target, (await request.body()).decode()))
    return {"status": "ok"}
@app.get("/status")
async def status():
    aios_db.write("services", {})
    aios_db.write("tasks", [])
    aios_db.write("schedule", {})
    return {"services": aios_db.read("services"), "tasks": aios_db.read("tasks"), "schedule": aios_db.read("schedule")}

# Get port from command line argument or default to 8000
api_port = int(sys.argv[1]) if len(sys.argv) > 1 else 8000
uvicorn.run(app, host="0.0.0.0", port=api_port)

services/backup.py:
#!/usr/bin/env python3
import sys, shutil
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
from pathlib import Path
import aios_db
from datetime import datetime
aios_db.write("backup", {"source": str(Path.home()), "dest": "/tmp/backup"})
aios_db.write("backup_log", [])
config = aios_db.read("backup")
source = Path(config.get("source", Path.home()))
dest = Path(config.get("dest", "/tmp/backup")) / f"{datetime.now():%Y%m%d_%H%M%S}"
dest.parent.mkdir(parents=True, exist_ok=True)
shutil.copytree(source, dest, dirs_exist_ok=True)
aios_db.write("backup_log", aios_db.read("backup_log") + [{"time": datetime.now().isoformat(), "dest": str(dest)}])
print(f"Backed up to {dest}")

services/service.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
aios_db.write("services", {})
services = aios_db.read("services")
command = (sys.argv + ["list"])[1]
name = (sys.argv + ["", None])[2]
def cmd_list():
    list(map(print, [f"{k}: {v.get('status', 'unknown')}" for k, v in services.items()]))
def cmd_start():
    aios_db.write("services", {**services, name: {**services.get(name, {}), "status": "running"}})
def cmd_stop():
    aios_db.write("services", {**services, name: {**services.get(name, {}), "status": "stopped"}})
def cmd_status():
    print({True: "specify service", False: services.get(name, {}).get("status", "unknown")}[name == None])
{"list": cmd_list, "start": cmd_start, "stop": cmd_stop, "status": cmd_status}.get(command, cmd_list)()

services/scraper.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import requests, aios_db
from bs4 import BeautifulSoup
from datetime import datetime
aios_db.write("scraper", {"urls": ["https://news.ycombinator.com"]})
config = aios_db.read("scraper")
def scrape_url(url):
    soup = BeautifulSoup(requests.get(url).text, 'html.parser')
    return {"url": url, "title": {True: "No title", False: soup.title.string}[soup.title == None], "time": datetime.now().isoformat()}
def print_result(r):
    print(f"{r['url']}: {r['title']}")
results = list(map(scrape_url, config.get("urls", [])))
aios_db.write("scraper_results", results)
list(map(print_result, results))

services/context_generator.py:
from pathlib import Path
from datetime import datetime
def generate():
    root = Path(__file__).parent.parent
    output = Path(root / "projectContext.txt")
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    files = [f for f in root.rglob("*.py")]
    readme = root / "README.md"
    content = f"Generated: {timestamp}\n\n"
    content += "\n".join([f"{f.relative_to(root)}:\n{f.read_text()}\n" for f in files])
    content += {True: "", False: f"\nREADME.md:\n{readme.read_text()}\n"}[readme.exists()]
    output.write_text(content)
    return str(output)

services/jobs.py:
#!/usr/bin/env python3
import sys, subprocess
sys.path.append("/home/seanpatten/projects/AIOS/core")
import aios_db
cmd = (sys.argv + ["list"])[1]
job_id = (sys.argv + ["", None])[2]
jobs = aios_db.query("jobs", "SELECT id, name, status, output FROM jobs ORDER BY created DESC")
def print_job(j):
    output_text = {True: (j[3] or 'No output')[:50], False: 'No output'}[j[3] != None]
    print(f"{j[0]}: {j[1]} - {j[2]} - {output_text}...")
def print_running(j):
    print(f'<div class="job-item">{j[1]} <span class="status running">Running...</span></div>')
def print_review(j):
    output = {True: (j[3] or "")[:50] + "...", False: ""}[j[3] != None]
    print(f'<div class="job-item">{j[1]} <span class="output">{output}</span>')
    print(f'<form action="/job/accept" method="POST" style="display:inline"><input type="hidden" name="id" value="{j[0]}"><button class="action-btn">Accept</button></form>')
    print(f'<form action="/job/redo" method="POST" style="display:inline"><input type="hidden" name="id" value="{j[0]}"><button class="action-btn">Redo</button></form></div>')
def print_done(j):
    output = {True: (j[3] or "")[:50] + "...", False: ""}[j[3] != None]
    print(f'<div class="job-item">{j[1]} <span class="output">{output}</span></div>')
def is_running(j):
    return j[2] == "running"
def is_review(j):
    return j[2] == "review"
def is_done(j):
    return j[2] == "done"
def cmd_summary():
    running = list(filter(is_running, jobs))
    review = list(filter(is_review, jobs))
    done = list(filter(is_done, jobs))[:5]
    summary = []
    list(map(summary.extend, [[f"RUN {j[1]}" for j in running[:2]], [f"? {j[1]}" for j in review[:1]], [f"DONE {j[1]}" for j in done[:1]]]))
    list(map(print, summary[:4]))
def cmd_running():
    list(map(print_running, filter(is_running, jobs[:10])))
def cmd_review():
    list(map(print_review, filter(is_review, jobs[:10])))
def cmd_done():
    list(map(print_done, filter(is_done, jobs[:50])))
def cmd_run_wiki():
    aios_db.execute("jobs", "INSERT INTO jobs(name, status) VALUES ('wiki', 'running')")
    new_id = aios_db.query("jobs", "SELECT MAX(id) FROM jobs")[0][0]
    subprocess.Popen(["python3", "programs/wiki_fetcher/wiki_fetcher.py", str(new_id)])
def cmd_accept():
    {True: None, False: aios_db.execute("jobs", "UPDATE jobs SET status='done' WHERE id=?", (int(job_id),))}[job_id == None]
def cmd_redo():
    {True: None, False: (aios_db.execute("jobs", "UPDATE jobs SET status='running' WHERE id=?", (int(job_id),)), subprocess.Popen(["python3", "programs/wiki_fetcher/wiki_fetcher.py", str(job_id)]))}[job_id == None]
def cmd_list():
    list(map(print_job, jobs[:20]))
{"summary": cmd_summary, "running": cmd_running, "review": cmd_review, "done": cmd_done, "run_wiki": cmd_run_wiki, "accept": cmd_accept, "redo": cmd_redo, "list": cmd_list}.get(cmd, cmd_list)()

services/processes.py:
#!/usr/bin/env python3
import sys, subprocess, json
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
from pathlib import Path
command = (sys.argv + ["json"])[1]
name = (sys.argv + ["", None])[2]
def get_time(x):
    return x["time"]
def is_not_archive(f):
    return ('archive' not in f.parts) * ('__pycache__' not in f.parts)
def get_all_processes():
    aios_db.write("schedule", {})
    aios_db.write("aios_pids", {})
    schedule = aios_db.read("schedule")
    pids = aios_db.read("aios_pids")
    python_files = list(Path('/home/seanpatten/projects/AIOS').rglob('*.py'))
    scheduled = sorted([{"path": cmd, "type": "daily", "time": time, "status": "scheduled"} for time, cmd in schedule.get("daily", {}).items()] + [{"path": cmd, "type": "hourly", "time": f":{int(m):02d}", "status": "scheduled"} for m, cmd in schedule.get("hourly", {}).items()], key=get_time)
    ongoing = [{"path": f"{k}_pid_{v}", "type": "running", "status": "active"} for k, v in pids.items()]
    core = [{"path": str(f.relative_to(Path('/home/seanpatten/projects/AIOS'))), "type": "file", "status": "available"} for f in python_files]
    return {"scheduled": scheduled, "ongoing": ongoing, "core": core}
def cmd_json():
    print(json.dumps(get_all_processes()))
def print_process(p):
    print(f"{p['path']}: {p['status']}")
def cmd_list():
    all_procs = get_all_processes()
    list(map(print_process, all_procs.get("scheduled", [])))
    list(map(print_process, all_procs.get("ongoing", [])))
    list(map(print_process, all_procs.get("core", [])))
def cmd_start():
    {True: None, False: subprocess.Popen(['python3', name])}[name == None]
def cmd_stop():
    {True: None, False: subprocess.run(['pkill', '-f', name], timeout=5)}[name == None]
{"json": cmd_json, "list": cmd_list, "start": cmd_start, "stop": cmd_stop}.get(command, cmd_json)()

services/feed.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
from datetime import datetime
command = (sys.argv + ["list"])[1]
def cmd_add():
    aios_db.execute("feed", "INSERT INTO messages(content, timestamp, source) VALUES (?, ?, ?)", (" ".join(sys.argv[2:]), datetime.now().isoformat(), "manual"))
def print_message(row):
    time_part = row[2].split('T')[1][:5]
    date_part = row[2].split('T')[0]
    print({True: f"{time_part} {row[1]}", False: f"{date_part} {time_part} {row[1]}"}[datetime.fromisoformat(row[2]).date() == datetime.now().date()])
def cmd_list():
    list(map(print_message, aios_db.query("feed", "SELECT id, content, timestamp, source FROM messages ORDER BY timestamp DESC LIMIT 50")))
def print_view_message(row, time_fmt):
    time_str = datetime.fromisoformat(row[2]).strftime(time_fmt)
    date_str = row[2].split('T')[0]
    print({True: f"{time_str} {row[1]}", False: f"{date_str} {time_str} {row[1]}"}[datetime.fromisoformat(row[2]).date() == datetime.now().date()])
def make_print_view(time_fmt):
    def print_wrapper(row):
        print_view_message(row, time_fmt)
    return print_wrapper
def cmd_view():
    aios_db.write('settings', {})
    settings = aios_db.read('settings')
    time_fmt = {True: '%I:%M %p', False: '%H:%M'}[settings.get('time_format', '12h') == '12h']
    messages = aios_db.query("feed", "SELECT id, content, timestamp, source FROM messages ORDER BY timestamp DESC LIMIT 50")
    list(map(make_print_view(time_fmt), messages))
def cmd_clear():
    aios_db.execute("feed", "DELETE FROM messages WHERE timestamp < datetime('now', '-7 days')")
{"add": cmd_add, "list": cmd_list, "view": cmd_view, "clear": cmd_clear}.get(command, cmd_list)()

programs/job_status.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
import subprocess

command = sys.argv[1] if len(sys.argv) > 1 else "summary"
job_id = sys.argv[2] if len(sys.argv) > 2 else None

jobs = aios_db.query("jobs", "SELECT id, name, status, output FROM jobs ORDER BY created DESC")

if command == "summary":
    running = [j for j in jobs if j[2] == "running"]
    review = [j for j in jobs if j[2] == "review"]
    done = [j for j in jobs if j[2] == "done"][:5]

    summary = []
    summary.extend([f"RUN {j[1]}" for j in running[:2]])
    summary.extend([f"? {j[1]}" for j in review[:1]])
    summary.extend([f"DONE {j[1]}" for j in done[:1]])

    for line in summary[:4]:
        print(line)

elif command == "running":
    running = [j for j in jobs if j[2] == "running"]
    for j in running[:10]:
        print(f'<div class="job-item">{j[1]} <span class="status running">Running...</span></div>')

elif command == "review":
    review = [j for j in jobs if j[2] == "review"]
    for j in review[:10]:
        output = (j[3] or "")[:50] + "..." if j[3] else ""
        print(f'<div class="job-item">{j[1]} <span class="output">{output}</span>')
        print(f'<form action="/job/accept" method="POST" style="display:inline"><input type="hidden" name="id" value="{j[0]}"><button class="action-btn">Accept</button></form>')
        print(f'<form action="/job/redo" method="POST" style="display:inline"><input type="hidden" name="id" value="{j[0]}"><button class="action-btn">Redo</button></form></div>')

elif command == "done":
    done = [j for j in jobs if j[2] == "done"]
    for j in done[:50]:
        output = (j[3] or "")[:50] + "..." if j[3] else ""
        print(f'<div class="job-item">{j[1]} <span class="output">{output}</span></div>')

elif command == "run_wiki":
    aios_db.execute("jobs", "INSERT INTO jobs(name, status) VALUES ('wiki', 'running')")
    job_id = aios_db.query("jobs", "SELECT MAX(id) FROM jobs")[0][0]
    subprocess.Popen(["python3", "programs/wiki_fetcher/wiki_fetcher.py", str(job_id)])

elif command == "accept" and job_id:
    aios_db.execute("jobs", "UPDATE jobs SET status='done' WHERE id=?", (int(job_id),))

elif command == "redo" and job_id:
    aios_db.execute("jobs", "UPDATE jobs SET status='running' WHERE id=?", (int(job_id),))
    subprocess.Popen(["python3", "programs/wiki_fetcher/wiki_fetcher.py", str(job_id)])

programs/ranker/ranker.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
from datetime import datetime
aios_db.write("ideas", [])
ideas = aios_db.read("ideas")
command = (sys.argv + ["list"])[1]
def score(idea):
    return len(idea.get('description', '')) * idea.get('impact', 1) / max(idea.get('effort', 1), 1)
def add():
    return aios_db.write("ideas", ideas + [{"description": ' '.join(sys.argv[2:]), "impact": 5, "effort": 5, "added": datetime.now().isoformat()}])
def print_item(x):
    print(f"{x[0]+1}. {x[1]['description']}")
def print_scored(x):
    print(f"{x[0]+1}. [{score(x[1]):.1f}] {x[1]['description']}")
def rank():
    list(map(print_scored, enumerate(sorted(ideas, key=score, reverse=True))))
def list_ideas():
    list(map(print_item, enumerate(ideas)))
def efficiency(x):
    return score(x)/x.get('effort', 5)
def pick():
    {False: print(f"Best: {sorted(ideas, key=efficiency, reverse=True)[0]['description']}"), True: None}[len(ideas) == 0]
{"add": add, "rank": rank, "list": list_ideas, "pick": pick}.get(command, list_ideas)()

programs/builder/builder.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import subprocess
from pathlib import Path
import aios_db
from datetime import datetime
import concurrent.futures

components = sys.argv[1:] or []
build_dir = Path.home() / ".aios" / "builds"
build_dir.mkdir(parents=True, exist_ok=True)

def build_component(name):
    result = subprocess.run(['echo', f'Building {name}'], capture_output=True, text=True, timeout=10)
    (build_dir / f"{name}.build").write_text(f"Built at {datetime.now()}")
    status_map = {0: "success"}
    return {"name": name, "status": status_map.get(result.returncode, "failed"), "time": datetime.now().isoformat()}

def print_result(r):
    print(f"{r['name']}: {r['status']}")

results = list(concurrent.futures.ThreadPoolExecutor(max_workers=4).map(build_component, components))
list(map(print_result, results))
aios_db.write("build_log", [])
existing_log = aios_db.read("build_log")
aios_db.write("build_log", existing_log + results)

programs/schedule/scheduler.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import schedule as sched
import subprocess
import aios_db

schedules = aios_db.read("schedule")

def run_cmd(cmd):
    return subprocess.run(cmd, shell=True, timeout=300)

def schedule_daily(item):
    t, cmd = item
    sched.every().day.at(t).do(run_cmd, cmd)

def schedule_hourly(item):
    m, cmd = item
    sched.every().hour.at(f":{int(m):02d}").do(run_cmd, cmd)

list(map(schedule_daily, schedules.get("daily", {}).items()))
list(map(schedule_hourly, schedules.get("hourly", {}).items()))

sched.run_pending()

programs/wiki_fetcher/wiki_fetcher.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
import aios_db
import urllib.request
import json

req = urllib.request.Request("https://en.wikipedia.org/api/rest_v1/page/random/summary", headers={'User-Agent': 'Mozilla/5.0'})
response = urllib.request.urlopen(req)
data = json.loads(response.read().decode())
output = f"{data.get('title', 'Unknown')}: {data.get('extract', 'No extract available')[:200]}..."
job_id = sys.argv[1:2] and sys.argv[1] or None

aios_db.execute("jobs", "UPDATE jobs SET output=?, status='review', updated=CURRENT_TIMESTAMP WHERE id=?", (output, job_id)) or print(output)

programs/planner/planner.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
from datetime import datetime
aios_db.write("tasks", [])
aios_db.write("daily_plan", {})
tasks = aios_db.read("tasks")
today = datetime.now().date()
plan = aios_db.read("daily_plan")
def is_pending(t):
    return (t.startswith("[x]") == False) * (t.startswith("[!]") == False)
def print_task(t):
    print(f"- {t}")
pending = list(filter(is_pending, tasks))
plan[str(today)] = pending[:10]
aios_db.write("daily_plan", plan)
list(map(print_task, plan[str(today)]))

programs/settings/settings.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS')
from core import aios_db
command = (sys.argv + ["set"])[1]
key = (sys.argv + ["set", "theme"])[2]
value = (sys.argv + ["set", "theme", ""])[3]
settings = aios_db.read("settings") or {}
[aios_db.write("settings", {**settings, key: value})] * (command == "set")
[print(settings.get(key, ""))] * (command == "get")


programs/swarm/swarm.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
import anthropic
from datetime import datetime

cache = aios_db.read("llm_cache") or {}
command = (sys.argv + ["list"])[1]
question = ' '.join(sys.argv[2:])

client = anthropic.Anthropic(api_key=(aios_db.read("api_keys") or {}).get("anthropic", ""))

def ask():
    response = client.messages.create(
        model="claude-3-haiku-20240307",
        max_tokens=500,
        messages=[{"role": "user", "content": question}]
    ).content[0].text
    cache[question] = {"response": response, "time": datetime.now().isoformat()}
    aios_db.write("llm_cache", cache)
    print(response)
    return cache

def print_item(item):
    q, a = item
    print(f"Q: {q[:50]}... A: {a['response'][:50]}...")

def list_cache():
    list(map(print_item, cache.items()))
    return cache

def clear():
    return aios_db.write("llm_cache", {})

def stats():
    print(f"Cached queries: {len(cache)}")
    return len(cache)

actions = {"ask": ask, "list": list_cache, "clear": clear, "stats": stats}
actions.get(command, list_cache)()

programs/todo/todo.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
from datetime import datetime, timedelta
command = (sys.argv + ["list"])[1]
def get_tasks():
    return aios_db.read("tasks")
tasks = get_tasks()
def add_task():
    task_text = ' '.join(sys.argv[2:])
    task_desc = task_text.split('@')[0].strip()
    new_task = f"[ ] {datetime.now():%Y-%m-%d %H:%M} {task_desc}"
    aios_db.write("tasks", get_tasks() + [new_task])
    aios_db.execute("feed", "INSERT INTO messages(content, timestamp, source) VALUES (?, ?, ?)", (f"Task: {task_desc}", datetime.now().isoformat(), "todo"))
def done_task():
    current_tasks = get_tasks()
    task_id = int(sys.argv[2]) - 1
    task = current_tasks[task_id]
    task_text = ' '.join(task.split()[3:])
    updated = list(current_tasks)
    updated[task_id] = task.replace("[ ]", "[x]")
    aios_db.write("tasks", updated)
    aios_db.execute("feed", "INSERT INTO messages(content, timestamp, source) VALUES (?, ?, ?)", (f"Completed: {task_text}", datetime.now().isoformat(), "todo"))
def print_task(item):
    i, t = item
    print(f"{i+1}. {t}")
def list_tasks():
    list(map(print_task, enumerate(tasks)))
def is_not_done(t):
    return t.startswith("[x]") == False
def clear_done():
    return aios_db.write("tasks", list(filter(is_not_done, tasks)))
{"list": list_tasks, "add": add_task, "done": done_task, "clear": clear_done}.get(command, list_tasks)()

programs/autollm/view_output.py:
#!/usr/bin/env python3
import sys
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

job_id = (sys.argv + [""])[1]
output_file = Path.home() / ".aios" / f"autollm_output_{job_id}.txt"
db_output = aios_db.query("autollm", "SELECT output FROM worktrees WHERE job_id=?", (job_id,))

print(output_file.read_text() * output_file.exists() or (db_output[0][0] or "No output yet") * bool(db_output) or "No output yet")

programs/autollm/capture_output.py:
#!/usr/bin/env python3
import subprocess
import sys
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

job_id = sys.argv[1]
output_file = Path.home() / ".aios" / f"autollm_output_{job_id}.txt"

cmd_type = sys.argv[2]
model = sys.argv[3]
task = " ".join(sys.argv[4:])

commands = {
    "claude": ["claude", task],
    "claude-dangerous": ["claude", "--dangerously-skip-permissions", task],
    "codex": ["codex", "-c", "model_reasoning_effort=high", "--model", model, "--dangerously-bypass-approvals-and-sandbox", task]
}

result = subprocess.run(commands.get(cmd_type, ["echo", "Invalid command"]), capture_output=True, text=True, timeout=999999)
output_file.write_text(result.stdout + result.stderr)
aios_db.execute("autollm", "UPDATE worktrees SET output=?, status='review' WHERE job_id=?", (result.stdout + result.stderr, job_id))
aios_db.execute("jobs", "UPDATE jobs SET output=?, status='review' WHERE id=?", (result.stdout + result.stderr, job_id))

programs/autollm/output_page.py:
#!/usr/bin/env python3
import sys
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

job_id = (sys.argv + [""])[1]
output_file = Path.home() / ".aios" / f"autollm_output_{job_id}.txt"
worktree = aios_db.query("autollm", "SELECT branch, task, model, status, output FROM worktrees WHERE job_id=?", (job_id,))

info = worktree[0] * bool(worktree) or ["unknown", "unknown", "unknown", "unknown", ""]
file_output = output_file.read_text() * output_file.exists() or (info[4] or "No output yet") * bool(worktree) or "No output yet"

print(f"Branch: {info[0]}")
print(f"Task: {info[1]}")
print(f"Model: {info[2]}")
print(f"Status: {info[3]}")
print(f"Output:\n{file_output}")

programs/autollm/llm.py:
#!/usr/bin/env python3
import subprocess
import sys

command = (sys.argv + ["claude"])[1]
model = (sys.argv + ["", "claude-3-5-sonnet-20241022"])[2]
task = " ".join(sys.argv[3:]) or "Improve this code"

commands = {
    "claude": ["claude", "--dangerously-skip-permissions", task],
    "codex": ["codex", "-c", "model_reasoning_effort=high", "--model", model, "--dangerously-bypass-approvals-and-sandbox", task]
}

subprocess.run(commands.get(command, commands["claude"]), timeout=999999)

programs/autollm/llm_test.py:
#!/usr/bin/env python3
import sys
print(f"LLM called with: command={sys.argv[1]}, model={sys.argv[2]}, task={' '.join(sys.argv[3:])}")

programs/autollm/autollm.py:
#!/usr/bin/env python3
import subprocess
import sys
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

command = (sys.argv + ["run"])[1]

def run():
    repo = (sys.argv + ["", "/home/seanpatten/projects/testRepoPrivate"])[2]
    branches = int((sys.argv + ["", "1"])[3])
    model = (sys.argv + ["", "claude-3-5-sonnet-20241022"])[4]
    task = " ".join(sys.argv[5:]) or "Improve code"

    list(map(lambda i: create_and_launch(repo, f"autollm-{Path(repo).name}-{i}", model, task), range(branches)))

def create_and_launch(repo, branch, model, task):
    path = str(Path(repo).parent / f"{Path(repo).name}-{branch}")
    subprocess.run(["git", "worktree", "add", "-b", branch, path], cwd=repo, capture_output=True, timeout=5)
    aios_db.execute("jobs", "INSERT INTO jobs(name, status) VALUES (?, 'running')", (branch,))
    job_id = aios_db.query("jobs", "SELECT MAX(id) FROM jobs")[0][0]
    aios_db.execute("autollm", "INSERT INTO worktrees(repo, branch, path, job_id, model, task, status) VALUES (?, ?, ?, ?, ?, ?, 'running')",
                    (repo, branch, path, job_id, model, task))

    cmd_type = "claude-dangerous" * (model == "claude-dangerous") or "claude" * (model.startswith("claude")) or "codex"
    subprocess.Popen(["python3", "/home/seanpatten/projects/AIOS/core/aios_runner.py", "python3", "/home/seanpatten/projects/AIOS/programs/autollm/capture_output.py", str(job_id), cmd_type, model, task], cwd=path, env={**subprocess.os.environ, "AIOS_TIMEOUT": "999999"})

def status():
    worktrees = aios_db.query("autollm", "SELECT branch, status FROM worktrees")
    list(map(lambda w: print(f"{w[0]}: {w[1]}"), worktrees))

def clean():
    done = aios_db.query("autollm", "SELECT repo, branch, path FROM worktrees WHERE status='done'")
    list(map(lambda w: subprocess.run(["git", "worktree", "remove", w[2]], cwd=w[0], capture_output=True, timeout=5), done))
    aios_db.execute("autollm", "DELETE FROM worktrees WHERE status='done'")

def output():
    job_id = (sys.argv + ["", ""])[2]
    result = aios_db.query("autollm", "SELECT output FROM worktrees WHERE job_id=?", (job_id,))
    print((result[0][0] or "") * bool(result) or "")

def accept():
    job_id = (sys.argv + ["", ""])[2]
    aios_db.execute("autollm", "UPDATE worktrees SET status='done' WHERE job_id=?", (job_id,))
    aios_db.execute("jobs", "UPDATE jobs SET status='done' WHERE id=?", (job_id,))

{"run": run, "status": status, "clean": clean, "output": output, "accept": accept}.get(command, run)()

programs/autollm/reset.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

aios_db.execute("autollm", "DROP TABLE IF EXISTS worktrees")
aios_db.execute("autollm", "CREATE TABLE IF NOT EXISTS worktrees(id INTEGER PRIMARY KEY, repo TEXT, branch TEXT, path TEXT, job_id INTEGER, model TEXT, task TEXT, status TEXT, output TEXT, created TIMESTAMP DEFAULT CURRENT_TIMESTAMP)")
print("Reset autollm database")

programs/autollm/terminal.py:
#!/usr/bin/env python3
import subprocess
import sys
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

job_id = (sys.argv + [""])[1]
worktree = aios_db.query("autollm", "SELECT path, output FROM worktrees WHERE job_id=?", (job_id,))
path = worktree[0][0]

output_file = Path(path) / ".autollm_output"
subprocess.run(["tail", "-f", str(output_file)], timeout=999999)

programs/autollm/monitor.py:
#!/usr/bin/env python3
import sys
import subprocess
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

worktrees = aios_db.query("autollm", "SELECT branch, path, job_id, status, model, task FROM worktrees")
list(map(lambda w: print(f"{w[0]}: {w[3]} | {w[4]} | {w[5][:30]}"), worktrees))

programs/workflow/workflow.py:
#!/usr/bin/env python3
import sys, json, subprocess
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
from pathlib import Path
from datetime import datetime

cmd = (sys.argv + ["list"])[1]

def get_workflows():
    try:
        return aios_db.read("workflows")
    except:
        aios_db.write("workflows", {})
        return {}

def get_nodes():
    try:
        return aios_db.read("workflow_nodes")
    except:
        aios_db.write("workflow_nodes", [])
        return []

def add_node():
    nodes = get_nodes()
    col = int((sys.argv + ["", "0"])[2])
    args = sys.argv[3:]
    folder = str(Path.cwd())
    text = " ".join(args)
    for i, arg in enumerate(args):
        if arg.startswith("/") and Path(arg).exists():
            folder = arg
            text = " ".join(args[:i] + args[i+1:])
            break
    node = {"id": len(nodes), "col": col, "text": text, "folder": folder, "parent": None, "children": [], "branch": None, "created": datetime.now().isoformat()}
    aios_db.write("workflow_nodes", nodes + [node])
    print(f"{node['id']}")

def list_nodes():
    cols = {}
    for n in get_nodes():
        cols.setdefault(n["col"], []).append(n)
    for c in sorted(cols.keys()):
        print(f"Column {c}:")
        list(map(lambda n: print(f"  {n['id']}: {n['text'][:50]}"), cols[c]))

def expand():
    nid = int((sys.argv + ["", "0"])[2])
    instruction = " ".join(sys.argv[3:])
    nodes = get_nodes()
    parent = nodes[nid]
    new_text = f"{parent['text']}\n{instruction}" if instruction else parent['text']
    child = {"id": len(nodes), "col": parent["col"] + 1, "text": new_text, "folder": parent["folder"], "parent": nid, "children": [], "branch": None, "created": datetime.now().isoformat()}
    nodes[nid]["children"].append(child["id"])
    aios_db.write("workflow_nodes", nodes + [child])
    print(f"{child['id']}")

def branch():
    nid = int((sys.argv + ["", "0"])[2])
    btype = (sys.argv + ["", "", "folder"])[3]
    nodes = get_nodes()
    node = nodes[nid]
    folder = node["folder"]
    if btype == "worktree":
        branch_name = f"workflow-{nid}-{datetime.now():%Y%m%d%H%M%S}"
        path = f"{folder}-{branch_name}"
        subprocess.run(["git", "worktree", "add", "-b", branch_name, path], cwd=folder, capture_output=True, timeout=5)
        nodes[nid]["branch"] = {"type": "worktree", "path": path, "branch": branch_name}
    elif btype == "subfolder":
        path = f"{folder}/workflow-{nid}"
        Path(path).mkdir(parents=True, exist_ok=True)
        nodes[nid]["branch"] = {"type": "subfolder", "path": path}
    else:
        nodes[nid]["branch"] = {"type": "main", "path": folder}
    aios_db.write("workflow_nodes", nodes)
    print(nodes[nid]["branch"]["path"])

def worktree_with_terminal():
    """Create a worktree and return terminal session info for PTY"""
    repo = (sys.argv + ["", "/home/seanpatten/projects/AIOS"])[2]
    branch_name = (sys.argv + ["", f"worktree_{datetime.now():%Y%m%d_%H%M%S}"])[3]

    # Create worktree path
    parent = Path(repo).parent
    worktree_path = parent / f"{Path(repo).name}_{branch_name}"

    # Create the worktree
    result = subprocess.run(
        ["git", "worktree", "add", "-b", branch_name, str(worktree_path)],
        cwd=repo,
        capture_output=True,
        text=True,
        timeout=10
    )

    if result.returncode != 0:
        print(json.dumps({"error": f"Failed to create worktree: {result.stderr}"}))
        return

    # Store worktree info
    try:
        worktrees = aios_db.read("worktrees_list")
    except:
        worktrees = []

    worktree_info = {
        "repo": str(repo),
        "branch": branch_name,
        "path": str(worktree_path),
        "created": datetime.now().isoformat()
    }
    worktrees.append(worktree_info)
    aios_db.write("worktrees_list", worktrees)

    # Return info for terminal creation
    print(json.dumps({
        "success": True,
        "branch": branch_name,
        "path": str(worktree_path),
        "message": f"Worktree created at {worktree_path}"
    }))

def execute():
    nid = int((sys.argv + ["", "0"])[2])
    nodes = get_nodes()
    node = nodes[nid]
    branch = node.get("branch") or {}
    path = branch.get("path") if branch else node["folder"]
    full_prompt = node["text"]
    parent_id = node.get("parent")
    while parent_id is not None:
        parent = nodes[parent_id]
        full_prompt = f"{parent['text']}\n{full_prompt}"
        parent_id = parent.get("parent")
    aios_db.execute("jobs", "INSERT INTO jobs(name, status, output) VALUES (?, 'running', ?)", (f"workflow-{nid}", node["text"]))
    job_id = aios_db.query("jobs", "SELECT MAX(id) FROM jobs")[0][0]
    subprocess.Popen(["claude", "--dangerously-skip-permissions", full_prompt], cwd=path, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    print(f"{job_id}")

def save_workflow():
    name = (sys.argv + ["", "default"])[2]
    workflows = get_workflows()
    workflows[name] = {"nodes": get_nodes(), "saved": datetime.now().isoformat()}
    aios_db.write("workflows", workflows)
    print(f"Saved: {name}")

def load_workflow():
    name = (sys.argv + ["", "default"])[2]
    workflows = get_workflows()
    aios_db.write("workflow_nodes", workflows.get(name, {}).get("nodes", []))
    print(f"Loaded: {name}")

def git_push():
    nid = int((sys.argv + ["", "0"])[2])
    msg = " ".join(sys.argv[3:]) or "workflow update"
    nodes = get_nodes()
    node = nodes[nid]
    branch = node.get("branch") or {}
    path = branch.get("path") if branch else node["folder"]
    subprocess.run(["git", "add", "."], cwd=path, timeout=5)
    subprocess.run(["git", "commit", "-m", msg], cwd=path, timeout=5, capture_output=True)
    result = subprocess.run(["git", "push"], cwd=path, timeout=5, capture_output=True, text=True)
    if "no upstream branch" in result.stderr:
        branch_name = subprocess.run(["git", "branch", "--show-current"], cwd=path, capture_output=True, text=True, timeout=5).stdout.strip()
        subprocess.run(["git", "push", "--set-upstream", "origin", branch_name], cwd=path, timeout=5)
    print(f"Pushed: {path}")

def terminal():
    nid = int((sys.argv + ["", "0"])[2])
    term = (sys.argv + ["", "", "gnome-terminal"])[3]
    nodes = get_nodes()
    node = nodes[nid]
    branch = node.get("branch") or {}
    path = branch.get("path") if branch else node["folder"]
    subprocess.Popen([term, "--working-directory", path])
    print(f"Terminal: {path}")

def comment():
    nid = int((sys.argv + ["", "0"])[2])
    text = " ".join(sys.argv[3:])
    nodes = get_nodes()
    nodes[nid].setdefault("comments", []).append({"text": text, "time": datetime.now().isoformat(), "author": "human"})
    aios_db.write("workflow_nodes", nodes)
    print(f"Comment added to {nid}")

{"add": add_node, "list": list_nodes, "expand": expand, "branch": branch, "exec": execute, "save": save_workflow, "load": load_workflow, "push": git_push, "term": terminal, "comment": comment, "worktree_terminal": worktree_with_terminal}.get(cmd, list_nodes)()


programs/worktree/worktree_manager.py:
#!/usr/bin/env python3
import sys
import subprocess
import os
from pathlib import Path
from datetime import datetime
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

def create_worktree_with_terminal(repo_path=None, branch_name=None):
    """Create a new git worktree and open a terminal in it"""

    # Default to AIOS project if no repo specified
    if not repo_path or repo_path == '':
        repo_path = '/home/seanpatten/projects/AIOS'

    # Check if it's a git repository
    try:
        subprocess.run(["git", "status"], cwd=repo_path, capture_output=True, check=True)
    except:
        return {"error": "Not a git repository", "path": repo_path}

    # Generate branch name if not provided
    if not branch_name:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        branch_name = f"worktree_{timestamp}"

    # Create worktree path
    parent = Path(repo_path).parent
    worktree_path = parent / f"{Path(repo_path).name}_{branch_name}"

    # Create the worktree
    try:
        result = subprocess.run(
            ["git", "worktree", "add", "-b", branch_name, str(worktree_path)],
            cwd=repo_path,
            capture_output=True,
            text=True,
            timeout=10
        )

        if result.returncode != 0:
            return {"error": f"Failed to create worktree: {result.stderr}", "branch": branch_name}

        # Store worktree info in database
        try:
            worktrees = aios_db.read("worktrees_list")
        except:
            worktrees = []
        worktrees.append({
            "repo": str(repo_path),
            "branch": branch_name,
            "path": str(worktree_path),
            "created": datetime.now().isoformat()
        })
        aios_db.write("worktrees_list", worktrees)

        # Try to open terminal (different commands for different environments)
        terminal_opened = False
        terminal_commands = [
            ["gnome-terminal", "--working-directory", str(worktree_path)],
            ["xterm", "-e", f"cd {worktree_path} && bash"],
            ["konsole", "--workdir", str(worktree_path)],
            ["xfce4-terminal", "--working-directory", str(worktree_path)]
        ]

        for cmd in terminal_commands:
            try:
                subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                terminal_opened = True
                break
            except:
                continue

        return {
            "success": True,
            "branch": branch_name,
            "path": str(worktree_path),
            "terminal": terminal_opened
        }

    except Exception as e:
        return {"error": str(e)}

def list_worktrees():
    """List all worktrees"""
    try:
        result = subprocess.run(
            ["git", "worktree", "list"],
            capture_output=True,
            text=True
        )
        return result.stdout
    except:
        return "Not a git repository"

def remove_worktree(path):
    """Remove a worktree"""
    try:
        subprocess.run(["git", "worktree", "remove", path], check=True)
        return f"Removed worktree: {path}"
    except Exception as e:
        return f"Error removing worktree: {e}"

if __name__ == "__main__":
    command = sys.argv[1] if len(sys.argv) > 1 else "create"

    if command == "create":
        repo = sys.argv[2] if len(sys.argv) > 2 else None
        branch = sys.argv[3] if len(sys.argv) > 3 else None
        result = create_worktree_with_terminal(repo, branch)
        if "success" in result and result["success"]:
            print(f"Created worktree: {result['path']}")
            print(f"Branch: {result['branch']}")
            if result["terminal"]:
                print("Terminal opened in worktree")
        else:
            print(f"Error: {result.get('error', 'Unknown error')}")

    elif command == "list":
        print(list_worktrees())

    elif command == "remove":
        path = sys.argv[2] if len(sys.argv) > 2 else None
        if path:
            print(remove_worktree(path))
        else:
            print("Please specify path to remove")

services/web/web.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
from http.server import HTTPServer, BaseHTTPRequestHandler
import json, aios_db, subprocess, os, asyncio, websockets, pty, struct, fcntl, termios
from urllib.parse import parse_qs, urlparse
from datetime import datetime
from pathlib import Path
from threading import Thread
import signal

TEMPLATE_DIR = Path(__file__).parent / 'templates'
DEV_MODE = os.getenv('DEV_MODE', 'true').lower() in ('1', 'true', 'yes')

# Get ports from arguments
WEB_PORT = int(sys.argv[2]) if len(sys.argv) > 2 else 8080
API_PORT = int(sys.argv[3]) if len(sys.argv) > 3 else 8000

def get_template(name):
    return (TEMPLATE_DIR / name).read_text() if DEV_MODE else globals().get(f'TEMPLATE_{name.replace(".html", "").replace("-", "_").upper()}', '')

TEMPLATE_INDEX = (TEMPLATE_DIR / 'index.html').read_text()
TEMPLATE_TODO = (TEMPLATE_DIR / 'todo.html').read_text()
TEMPLATE_JOBS = (TEMPLATE_DIR / 'jobs.html').read_text()
TEMPLATE_FEED = (TEMPLATE_DIR / 'feed.html').read_text()
TEMPLATE_AUTOLLM = (TEMPLATE_DIR / 'autollm.html').read_text()
TEMPLATE_AUTOLLM_OUTPUT = (TEMPLATE_DIR / 'autollm_output.html').read_text()
TEMPLATE_TERMINAL = (TEMPLATE_DIR / 'terminal.html').read_text()
TEMPLATE_TERMINAL_EMULATOR = (TEMPLATE_DIR / 'terminal-emulator.html').read_text()
TEMPLATE_TERMINAL_XTERM = (TEMPLATE_DIR / 'terminal-xterm.html').read_text()
TEMPLATE_SETTINGS = (TEMPLATE_DIR / 'settings.html').read_text()
TEMPLATE_WORKFLOW = (TEMPLATE_DIR / 'workflow.html').read_text()
TEMPLATE_WORKFLOW_MANAGER = (TEMPLATE_DIR / 'workflow_manager.html').read_text() if (TEMPLATE_DIR / 'workflow_manager.html').exists() else ''

class Handler(BaseHTTPRequestHandler):
    def do_GET(self):
        parsed = urlparse(self.path)
        path = parsed.path
        query = parse_qs(parsed.query)
        s = aios_db.read("settings") or {}
        c = {'bg': {'light': '#fff'}.get(s.get('theme'), '#000'), 'fg': {'light': '#000'}.get(s.get('theme'), '#fff'), 'bg2': {'light': '#f0f0f0'}.get(s.get('theme'), '#1a1a1a')}
        self.s = s
        self.c = c
        self.query = query
        handlers = {'/api/jobs': self.handle_api_jobs, '/api/workflow/nodes': self.handle_api_workflow_nodes, '/': self.handle_home, '/todo': self.handle_todo, '/feed': self.handle_feed, '/settings': self.handle_settings, '/jobs': self.handle_jobs, '/autollm': self.handle_autollm, '/autollm/output': self.handle_autollm_output, '/terminal': self.handle_terminal, '/terminal-emulator': self.handle_terminal_emulator, '/terminal-xterm': self.handle_terminal_xterm, '/workflow': self.handle_workflow, '/workflow-manager': self.handle_workflow_manager, '/workflow/list_worktrees': self.handle_list_worktrees}
        content, ctype = handlers.get(path, self.handle_default)()
        self.send_response(200)
        self.send_header('Content-type', ctype)
        self.end_headers()
        self.wfile.write(content.encode())

    def handle_default(self):
        return (TEMPLATE_INDEX.format(**self.c, vp="", tasks="", feed_content="", running_jobs="", review_jobs="", done_jobs=""), 'text/html')

    def handle_api_jobs(self):
        return (json.dumps(list(map(lambda j: {"id": j[0], "name": j[1], "status": j[2], "output": j[3]}, aios_db.query("jobs", "SELECT id, name, status, output FROM jobs ORDER BY created DESC")))), 'application/json')

    def handle_home(self):
        return (TEMPLATE_INDEX.format(**self.c), 'text/html')

    def handle_todo(self):
        result = subprocess.run(["python3", "core/aios_runner.py", "python3", "programs/todo/todo.py", "list"], capture_output=True, text=True)
        tasks = result.stdout.strip().split('\n') or []
        tasks_html = "".join(list(map(lambda it: f'<div class="task {"done" * ("[x]" in it[1])}">{it[1]} <form style="display:inline" action="/todo/done" method="POST"><input type="hidden" name="id" value="{it[1].split(".")[0] or str(it[0]+1)}"><button>Done</button></form></div>', enumerate(tasks))))
        return TEMPLATE_TODO.format(**self.c, tasks=tasks_html or '<div style="color:#888">No tasks yet</div>'), 'text/html'

    def handle_feed(self):
        messages = aios_db.query("feed", "SELECT content, timestamp FROM messages ORDER BY timestamp DESC LIMIT 100")
        time_format = self.s.get("time_format", "12h")
        feed_html = []
        self._dates = []
        def process_message(m):
            date_header = {True: f'<div style="color:#888;font-weight:bold;margin:15px 0 5px">{datetime.fromisoformat(m[1]).date()}</div>', False: ''}.get(datetime.fromisoformat(m[1]).date() not in self._dates, '')
            feed_html.append(date_header + f'<div style="padding:8px;margin:2px 0">{datetime.fromisoformat(m[1]).strftime({"12h": "%I:%M %p"}.get(time_format, "%H:%M"))} - {m[0]}</div>')
            self._dates.append(datetime.fromisoformat(m[1]).date())
        list(map(process_message, messages))
        return TEMPLATE_FEED.format(**self.c, feed_content="".join(feed_html) or "<div style='color:#888'>No messages yet</div>"), 'text/html'

    def handle_settings(self):
        theme_dark_style = {'dark': 'style="font-weight:bold"'}.get(self.s.get('theme', 'dark'), '')
        theme_light_style = {'light': 'style="font-weight:bold"'}.get(self.s.get('theme'), '')
        time_12h_style = {'12h': 'style="font-weight:bold"'}.get(self.s.get('time_format', '12h'), '')
        time_24h_style = {'24h': 'style="font-weight:bold"'}.get(self.s.get('time_format'), '')
        return TEMPLATE_SETTINGS.format(**self.c, theme_dark_style=theme_dark_style, theme_light_style=theme_light_style, time_12h_style=time_12h_style, time_24h_style=time_24h_style), 'text/html'

    def handle_jobs(self):
        running = subprocess.run("python3 services/jobs.py running", shell=True, capture_output=True, text=True, timeout=5)
        review = subprocess.run("python3 services/jobs.py review", shell=True, capture_output=True, text=True, timeout=5)
        done = subprocess.run("python3 services/jobs.py done", shell=True, capture_output=True, text=True, timeout=5)
        running_html = running.stdout.strip() or '<div style="color:#888;padding:10px">No running jobs</div>'
        review_html = review.stdout.strip() or '<div style="color:#888;padding:10px">No jobs in review</div>'
        done_html = done.stdout.strip() or '<div style="color:#888;padding:10px">No completed jobs</div>'
        return TEMPLATE_JOBS.format(**self.c, running_jobs=running_html, review_jobs=review_html, done_jobs=done_html), 'text/html'

    def handle_autollm(self):
        worktrees = aios_db.query("autollm", "SELECT branch, path, job_id, status, task, model, output FROM worktrees")
        running = []
        review = []
        done = []
        for w in worktrees:
            if w[3] == 'running': running.append((w[0], w[1], w[2], w[4], w[5]))
            elif w[3] == 'review': review.append((w[0], w[1], w[2], w[4], w[5], w[6]))
            elif w[3] == 'done': done.append((w[0], w[1]))
        running_html = "".join(list(map(lambda w: f'<div class="worktree"><span class="status running">{w[0]}</span><br>{w[4]}: {w[3][:30]}<br><pre style="background:#000;padding:5px;margin:5px 0;max-height:100px;overflow-y:auto;font-size:10px">{((Path.home() / ".aios" / f"autollm_output_{w[2]}.txt").read_text()[-200:] if (Path.home() / ".aios" / f"autollm_output_{w[2]}.txt").exists() else "Waiting for output...")}</pre><a href="/autollm/output?job_id={w[2]}" style="padding:5px 10px;background:{self.c["fg"]};color:{self.c["bg"]};text-decoration:none;border-radius:3px">Full Output</a><a href="/terminal?job_id={w[2]}" style="padding:5px 10px;background:{self.c["fg"]};color:{self.c["bg"]};text-decoration:none;border-radius:3px;margin-left:5px">Terminal</a></div>', running))) or '<div style="color:#888">No running worktrees</div>'
        review_html = "".join(list(map(lambda w: f'<div class="worktree"><span class="status review">{w[0]}</span><br>{w[4]}: {w[3][:30]}<br>Output: {(w[5] or "")[:50]}<br><form action="/autollm/accept" method="POST" style="display:inline"><input type="hidden" name="job_id" value="{w[2]}"><button>Accept</button></form><form action="/autollm/vscode" method="POST" style="display:inline"><input type="hidden" name="path" value="{w[1]}"><button>VSCode</button></form></div>', review))) or '<div style="color:#888">No worktrees in review</div>'
        done_html = "".join(list(map(lambda w: f'<div class="worktree"><span class="status done">{w[0]}</span></div>', done))) or '<div style="color:#888">No completed worktrees</div>'
        return TEMPLATE_AUTOLLM.format(**self.c, running_worktrees=running_html, review_worktrees=review_html, done_worktrees=done_html), 'text/html'

    def handle_autollm_output(self):
        job_id = self.query.get('job_id', [''])[0]
        output_file = Path.home() / ".aios" / f"autollm_output_{job_id}.txt"
        db_output = aios_db.query("autollm", "SELECT output FROM worktrees WHERE job_id=?", (job_id,))
        output_content = output_file.read_text() * output_file.exists() or (db_output[0][0] or "No output yet") * bool(db_output) or "No output yet"
        return TEMPLATE_AUTOLLM_OUTPUT.format(**self.c, output_content=output_content), 'text/html'

    def handle_terminal(self):
        job_id = self.query.get('job_id', [''])[0]
        output_file = Path.home() / ".aios" / f"autollm_output_{job_id}.txt"
        terminal_content = (output_file.exists() and output_file.read_text()) or "Waiting for output..."
        return TEMPLATE_TERMINAL.format(**self.c, terminal_content=terminal_content, job_id=job_id), 'text/html'

    def handle_terminal_emulator(self):
        return (TEMPLATE_TERMINAL_EMULATOR, 'text/html')

    def handle_terminal_xterm(self):
        return (TEMPLATE_TERMINAL_XTERM, 'text/html')

    def handle_workflow(self):
        template = get_template('workflow.html') if DEV_MODE else TEMPLATE_WORKFLOW
        return (template.format(**self.c), 'text/html')

    def handle_workflow_manager(self):
        template = get_template('workflow_manager.html') if DEV_MODE else TEMPLATE_WORKFLOW_MANAGER
        return (template.format(**self.c), 'text/html')

    def handle_list_worktrees(self):
        # Get list of worktrees from git
        result = subprocess.run(["git", "worktree", "list"], capture_output=True, text=True, timeout=5)
        worktrees = []
        for line in result.stdout.strip().split('\n'):
            if line:
                parts = line.split()
                if len(parts) >= 3:
                    path = parts[0]
                    branch = parts[2].strip('[]')
                    worktrees.append({"path": path, "branch": branch})
        return (json.dumps(worktrees), 'application/json')

    def handle_api_workflow_nodes(self):
        try:
            nodes = aios_db.read("workflow_nodes")
        except:
            nodes = []
        return (json.dumps(nodes), 'application/json')

    def do_POST(self):
        path = urlparse(self.path).path
        length = int(self.headers.get('Content-Length', 0))
        body = self.rfile.read(length) or b''
        if path.startswith('/workflow/'):
            jdata = json.loads(body.decode() or '{}')

            # Handle worktree creation with terminal
            if path == '/workflow/worktree_terminal':
                repo = jdata.get('repo', '/home/seanpatten/projects/AIOS')
                branch = jdata.get('branch', '')
                result = subprocess.run(
                    ["python3", "programs/workflow/workflow.py", "worktree_terminal", repo, branch],
                    capture_output=True,
                    text=True,
                    timeout=10
                )
                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                try:
                    output = json.loads(result.stdout) if result.stdout else {"error": "No output from command"}
                except:
                    output = {"error": result.stderr or "Unknown error"}
                self.wfile.write(json.dumps(output).encode())
                return

            # Handle worktree removal
            if path == '/workflow/remove_worktree':
                worktree_path = jdata.get('path', '')
                try:
                    subprocess.run(["git", "worktree", "remove", worktree_path], check=True, timeout=5)
                    response = {"success": True}
                except Exception as e:
                    response = {"success": False, "error": str(e)}
                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(json.dumps(response).encode())
                return

            # Existing workflow commands
            wf_cmds = {'/workflow/add': f"python3 programs/workflow/workflow.py add {jdata.get('col', 0)} {jdata.get('text', '')}", '/workflow/expand': f"python3 programs/workflow/workflow.py expand {jdata.get('id', 0)} {jdata.get('text', '')}", '/workflow/branch': f"python3 programs/workflow/workflow.py branch {jdata.get('id', 0)}", '/workflow/exec': f"python3 programs/workflow/workflow.py exec {jdata.get('id', 0)}", '/workflow/push': f"python3 programs/workflow/workflow.py push {jdata.get('id', 0)}", '/workflow/term': f"python3 programs/workflow/workflow.py term {jdata.get('id', 0)}", '/workflow/comment': f"python3 programs/workflow/workflow.py comment {jdata.get('id', 0)} {jdata.get('text', '')}", '/workflow/save': f"python3 programs/workflow/workflow.py save {jdata.get('name', 'default')}", '/workflow/load': f"python3 programs/workflow/workflow.py load {jdata.get('name', 'default')}"}
            subprocess.run(wf_cmds.get(path, ""), shell=True, timeout=5, capture_output=True)
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            self.wfile.write(b'{"status":"ok"}')
            return
        # Handle shutdown and restart
        if path == '/shutdown':
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            self.wfile.write(b'<html><body><h1>Shutting down AIOS...</h1><script>setTimeout(function(){window.close();}, 2000);</script></body></html>')
            # Kill API and web processes
            pids = aios_db.read("aios_pids")
            for pid in pids.values():
                try:
                    os.kill(pid, signal.SIGTERM)
                except:
                    pass
            os._exit(0)
            return
        elif path == '/restart':
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            self.wfile.write(b'<html><body><h1>Restarting AIOS...</h1><script>setTimeout(function(){location.reload();}, 3000);</script></body></html>')
            # Start new instance and shutdown current
            subprocess.Popen(["python3", "/home/seanpatten/projects/AIOS/core/aios_start.py"])
            # Kill current processes after delay
            def delayed_shutdown():
                import time
                time.sleep(1)
                pids = aios_db.read("aios_pids")
                for pid in pids.values():
                    try:
                        os.kill(pid, signal.SIGTERM)
                    except:
                        pass
                os._exit(0)
            Thread(target=delayed_shutdown, daemon=True).start()
            return

        # Handle worktree creation
        if path == '/worktree/create':
            data = parse_qs(body.decode()) or {}
            repo = data.get('repo', [''])[0]
            branch = data.get('branch', [''])[0]
            result = subprocess.run(
                ["python3", "/home/seanpatten/projects/AIOS/programs/worktree/worktree_manager.py", "create", repo, branch],
                capture_output=True,
                text=True,
                timeout=10
            )
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            output = result.stdout if result.returncode == 0 else f"Error: {result.stderr}"
            self.wfile.write(f'<html><body><h2>Worktree Created</h2><pre>{output}</pre><br><a href="/">Back to Control Center</a></body></html>'.encode())
            return

        data = parse_qs(body.decode()) or {}
        commands = {'/job/run': "python3 services/jobs.py run_wiki", '/job/accept': f"python3 services/jobs.py accept {data.get('id', [''])[0]}", '/job/redo': f"python3 services/jobs.py redo {data.get('id', [''])[0]}", '/run': data.get('cmd', [''])[0], '/todo/add': f"python3 programs/todo/todo.py add {data.get('task', [''])[0]}", '/todo/done': f"python3 programs/todo/todo.py done {data.get('id', [''])[0]}", '/todo/clear': "python3 programs/todo/todo.py clear", '/settings/theme': f"python3 programs/settings/settings.py set theme {data.get('theme', ['dark'])[0]}", '/settings/time': f"python3 programs/settings/settings.py set time_format {data.get('format', ['12h'])[0]}", '/autollm/run': f"python3 programs/autollm/autollm.py run {data.get('repo', [''])[0]} {data.get('branches', ['1'])[0]} {data.get('model', ['claude-3-5-sonnet-20241022'])[0]} {data.get('task', [''])[0]}", '/autollm/accept': f"python3 programs/autollm/autollm.py accept {data.get('job_id', [''])[0]}", '/autollm/vscode': f"code {data.get('path', [''])[0]}", '/autollm/clean': "python3 programs/autollm/autollm.py clean"}
        cmd = commands.get(path, "")
        subprocess.run(cmd, shell=True, timeout=5, capture_output=True)
        self.send_response(303)
        self.send_header('Location', {True: '/autollm', False: {True: '/settings', False: path.replace('/add', '').replace('/done', '').replace('/clear', '')}['settings' in path]}['autollm' in path])
        self.end_headers()

    def log_message(self, *args): pass

async def client_handler(ws):
    master, slave = pty.openpty()
    winsize = struct.pack('HHHH', 24, 80, 0, 0)
    fcntl.ioctl(slave, termios.TIOCSWINSZ, winsize)
    proc = await asyncio.create_subprocess_exec('bash', stdin=slave, stdout=slave, stderr=slave, preexec_fn=os.setsid)
    os.close(slave)
    os.set_blocking(master, False)
    loop = asyncio.get_event_loop()
    def read_output():
        try:
            data = os.read(master, 65536)
            if data: asyncio.create_task(ws.send(data))
        except (OSError, BlockingIOError): pass
    loop.add_reader(master, read_output)
    try:
        async for msg in ws:
            if isinstance(msg, bytes):
                try:
                    data = json.loads(msg.decode('utf-8'))
                    if 'resize' in data:
                        size = data['resize']
                        winsize = struct.pack('HHHH', size['rows'], size['cols'], 0, 0)
                        fcntl.ioctl(master, termios.TIOCSWINSZ, winsize)
                        if 'term' in data: os.environ['TERM'] = data['term']
                except: os.write(master, msg)
    finally:
        loop.remove_reader(master)
        proc.terminate()
        await proc.wait()
        os.close(master)

def serve_http(sock=None):
    server = HTTPServer(('', 8080), Handler, bind_and_activate=(sock is None))
    {True: setattr(server, 'socket', sock), False: None}[sock is not None]
    server.serve_forever()

async def main():
    import socket
    sock = socket.fromfd(int(sys.argv[1]), socket.AF_INET, socket.SOCK_STREAM) if len(sys.argv) > 1 else None
    Thread(target=serve_http, args=(sock,), daemon=True).start()
    # Use dynamic websocket port based on web port
    ws_port = WEB_PORT + 1000  # e.g., 8080 -> 9080
    try:
        async with websockets.serve(client_handler, 'localhost', ws_port):
            await asyncio.Future()
    except OSError:
        # Try alternative port if first one is taken
        ws_port = WEB_PORT + 2000
        async with websockets.serve(client_handler, 'localhost', ws_port):
            await asyncio.Future()

asyncio.run(main())

